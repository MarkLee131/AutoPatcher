cwe_id,vuln_code,fix_code,project_and_commit_id,cve_id,original_address,time
CWE-416,"CWE-416 static void mark_context_stack ( mrb_state * mrb , struct mrb_context * c ) { size_t i ; <S2SV_StartBug> size_t e ; <S2SV_EndBug> if ( c -> stack == NULL ) return ; e = c -> stack - c -> stbase ; if ( c -> ci ) e += c -> ci -> nregs ; if ( c -> stbase + e > c -> stend ) e = c -> stend - c -> stbase ; for ( i = 0 ; i < e ; i ++ ) { mrb_value v = c -> stbase [ i ] ; if ( ! mrb_immediate_p ( v ) ) { <S2SV_StartBug> if ( mrb_basic_ptr ( v ) -> tt == MRB_TT_FREE ) { <S2SV_EndBug> c -> stbase [ i ] = mrb_nil_value ( ) ; } else { mrb_gc_mark ( mrb , mrb_basic_ptr ( v ) ) ; } } <S2SV_StartBug> } <S2SV_EndBug> }
","<S2SV_ModStart> ; size_t e ; mrb_value nil <S2SV_ModStart> ) ) { <S2SV_ModEnd> mrb_gc_mark ( mrb <S2SV_ModStart> ; } } e = c -> stend - c -> stbase ; nil = mrb_nil_value ( ) ; for ( ; i < e ; i ++ ) { c -> stbase [ i ] = nil ;
",mruby@mruby/5c114c91d4ff31859fcd84cf8bf349b737b90d99,CVE-2017-9527,https://github.com/mruby/mruby/commit/5c114c91d4ff31859fcd84cf8bf349b737b90d99,2017-06-11T17:29Z
CWE-416,"CWE-416 static void snd_usb_mixer_free ( struct usb_mixer_interface * mixer ) <S2SV_StartBug> { <S2SV_EndBug> kfree ( mixer -> id_elems ) ; if ( mixer -> urb ) { kfree ( mixer -> urb -> transfer_buffer ) ; usb_free_urb ( mixer -> urb ) ; } usb_free_urb ( mixer -> rc_urb ) ; kfree ( mixer -> rc_setup_packet ) ; kfree ( mixer ) ; }","<S2SV_ModStart> mixer ) { snd_usb_mixer_disconnect ( mixer ) ;",torvalds@linux/124751d5e63c823092060074bd0abaae61aaa9c4,CVE-2017-16527,https://github.com/torvalds/linux/commit/124751d5e63c823092060074bd0abaae61aaa9c4,2017-11-04T01:29Z
CWE-190,"CWE-190 mrb_value *regs_a = regs + a;\nstruct REnv *e = uvenv(mrb, c);\n<S2SV_StartBug>\nif (!e) {\n\n    *regs_a = mrb_nil_value();\n    }\nelse {\n    *regs_a = e->stack[b];<S2SV_EndBug>\n    \n    NEXT;\n    }","<S2SV_ModStart>if (e && b < MRB_ENV_STACK_LEN(e)) {\n    *regs_a = e->stack[b];\n}\nelse {\n    *regs_a = mrb_nil_value();\n}<S2SV_ModEnd>",mruby@mruby/1905091634a6a2925c911484434448e568330626,CVE-2018-10191,https://github.com/mruby/mruby/commit/1905091634a6a2925c911484434448e568330626,2018-04-11T09:00Z
CWE-119,"CWE-119 bool initiate_stratum ( struct pool * pool ) { bool ret = false , recvd = false , noresume = false , sockd = false ; char s [ RBUFSIZE ] , * sret = NULL , * nonce1 , * sessionid ; json_t * val = NULL , * res_val , * err_val ; json_error_t err ; int n2size ; resend : if ( ! setup_stratum_socket ( pool ) ) { sockd = false ; goto out ; } sockd = true ; if ( recvd ) { clear_sock ( pool ) ; sprintf ( s , ""{\\""id\\"":<S2SV_blank>%d,<S2SV_blank>\\""method\\"":<S2SV_blank>\\""mining.subscribe\\"",<S2SV_blank>\\""params\\"":<S2SV_blank>[]}"" , swork_id ++ ) ; } else { if ( pool -> sessionid ) sprintf ( s , ""{\\""id\\"":<S2SV_blank>%d,<S2SV_blank>\\""method\\"":<S2SV_blank>\\""mining.subscribe\\"",<S2SV_blank>\\""params\\"":<S2SV_blank>[\\"""" PACKAGE ""/"" VERSION ""\\"",<S2SV_blank>\\""%s\\""]}"" , swork_id ++ , pool -> sessionid ) ; else sprintf ( s , ""{\\""id\\"":<S2SV_blank>%d,<S2SV_blank>\\""method\\"":<S2SV_blank>\\""mining.subscribe\\"",<S2SV_blank>\\""params\\"":<S2SV_blank>[\\"""" PACKAGE ""/"" VERSION ""\\""]}"" , swork_id ++ ) ; } if ( __stratum_send ( pool , s , strlen ( s ) ) != SEND_OK ) { applog ( LOG_DEBUG , ""Failed<S2SV_blank>to<S2SV_blank>send<S2SV_blank>s<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; goto out ; } if ( ! socket_full ( pool , DEFAULT_SOCKWAIT ) ) { applog ( LOG_DEBUG , ""Timed<S2SV_blank>out<S2SV_blank>waiting<S2SV_blank>for<S2SV_blank>response<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; goto out ; } sret = recv_line ( pool ) ; if ( ! sret ) goto out ; recvd = true ; val = JSON_LOADS ( sret , & err ) ; free ( sret ) ; if ( ! val ) { applog ( LOG_INFO , ""JSON<S2SV_blank>decode<S2SV_blank>failed(%d):<S2SV_blank>%s"" , err . line , err . text ) ; goto out ; } res_val = json_object_get ( val , ""result"" ) ; err_val = json_object_get ( val , ""error"" ) ; if ( ! res_val || json_is_null ( res_val ) || ( err_val && ! json_is_null ( err_val ) ) ) { char * ss ; if ( err_val ) ss = json_dumps ( err_val , JSON_INDENT ( 3 ) ) ; else ss = strdup ( ""(unknown<S2SV_blank>reason)"" ) ; applog ( LOG_INFO , ""JSON-RPC<S2SV_blank>decode<S2SV_blank>failed:<S2SV_blank>%s"" , ss ) ; free ( ss ) ; goto out ; } sessionid = get_sessionid ( res_val ) ; if ( ! sessionid ) applog ( LOG_DEBUG , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>sessionid<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; nonce1 = json_array_string ( res_val , 1 ) ; <S2SV_StartBug> if ( ! nonce1 ) { <S2SV_EndBug> <S2SV_StartBug> applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; <S2SV_EndBug> free ( sessionid ) ; goto out ; } n2size = json_integer_value ( json_array_get ( res_val , 2 ) ) ; <S2SV_StartBug> if ( ! n2size ) { <S2SV_EndBug> <S2SV_StartBug> applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; <S2SV_EndBug> free ( sessionid ) ; free ( nonce1 ) ; goto out ; } cg_wlock ( & pool -> data_lock ) ; pool -> sessionid = sessionid ; pool -> nonce1 = nonce1 ; pool -> n1_len = strlen ( nonce1 ) / 2 ; free ( pool -> nonce1bin ) ; pool -> nonce1bin = calloc ( pool -> n1_len , 1 ) ; if ( unlikely ( ! pool -> nonce1bin ) ) quithere ( 1 , ""Failed<S2SV_blank>to<S2SV_blank>calloc<S2SV_blank>pool->nonce1bin"" ) ; hex2bin ( pool -> nonce1bin , pool -> nonce1 , pool -> n1_len ) ; pool -> n2size = n2size ; cg_wunlock ( & pool -> data_lock ) ; if ( sessionid ) applog ( LOG_DEBUG , ""Pool<S2SV_blank>%d<S2SV_blank>stratum<S2SV_blank>session<S2SV_blank>id:<S2SV_blank>%s"" , pool -> pool_no , pool -> sessionid ) ; ret = true ; out : if ( ret ) { if ( ! pool -> stratum_url ) pool -> stratum_url = pool -> sockaddr_url ; pool -> stratum_active = true ; pool -> sdiff = 1 ; if ( opt_protocol ) { applog ( LOG_DEBUG , ""Pool<S2SV_blank>%d<S2SV_blank>confirmed<S2SV_blank>mining.subscribe<S2SV_blank>with<S2SV_blank>extranonce1<S2SV_blank>%s<S2SV_blank>extran2size<S2SV_blank>%d"" , pool -> pool_no , pool -> nonce1 , pool -> n2size ) ; } } else { if ( recvd && ! noresume ) { cg_wlock ( & pool -> data_lock ) ; free ( pool -> sessionid ) ; free ( pool -> nonce1 ) ; pool -> sessionid = pool -> nonce1 = NULL ; cg_wunlock ( & pool -> data_lock ) ; applog ( LOG_DEBUG , ""Failed<S2SV_blank>to<S2SV_blank>resume<S2SV_blank>stratum,<S2SV_blank>trying<S2SV_blank>afresh"" ) ; noresume = true ; json_decref ( val ) ; goto resend ; } applog ( LOG_DEBUG , ""Initiate<S2SV_blank>stratum<S2SV_blank>failed"" ) ; if ( sockd ) suspend_stratum ( pool ) ; } json_decref ( val ) ; return ret ; }
","<S2SV_ModStart> if ( ! valid_hex ( nonce1 ) <S2SV_ModEnd> ) { applog <S2SV_ModStart> ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>valid<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum"" <S2SV_ModEnd> ) ; free <S2SV_ModStart> ; if ( n2size < 2 || n2size > 16 <S2SV_ModEnd> ) { applog <S2SV_ModStart> ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>valid<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" <S2SV_ModEnd> ) ; free
",sgminer-dev@sgminer/bac5831b355f916e0696b7bbcccfc51c057b729a,CVE-2014-4502,https://github.com/sgminer-dev/sgminer/commit/bac5831b355f916e0696b7bbcccfc51c057b729a,2014-07-23T14:55Z
CWE-119,"CWE-119 static struct se_portal_group * vhost_scsi_make_tpg ( struct se_wwn * wwn , struct config_group * group , const char * name ) { struct vhost_scsi_tport * tport = container_of ( wwn , struct vhost_scsi_tport , tport_wwn ) ; struct vhost_scsi_tpg * tpg ; <S2SV_StartBug> unsigned long tpgt ; <S2SV_EndBug> int ret ; if ( strstr ( name , ""tpgt_"" ) != name ) return ERR_PTR ( - EINVAL ) ; <S2SV_StartBug> if ( kstrtoul ( name + 5 , 10 , & tpgt ) || tpgt > UINT_MAX ) <S2SV_EndBug> return ERR_PTR ( - EINVAL ) ; tpg = kzalloc ( sizeof ( struct vhost_scsi_tpg ) , GFP_KERNEL ) ; if ( ! tpg ) { pr_err ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>struct<S2SV_blank>vhost_scsi_tpg"" ) ; return ERR_PTR ( - ENOMEM ) ; } mutex_init ( & tpg -> tv_tpg_mutex ) ; INIT_LIST_HEAD ( & tpg -> tv_tpg_list ) ; tpg -> tport = tport ; tpg -> tport_tpgt = tpgt ; ret = core_tpg_register ( & vhost_scsi_fabric_configfs -> tf_ops , wwn , & tpg -> se_tpg , tpg , TRANSPORT_TPG_TYPE_NORMAL ) ; if ( ret < 0 ) { kfree ( tpg ) ; return NULL ; } mutex_lock ( & vhost_scsi_mutex ) ; list_add_tail ( & tpg -> tv_tpg_list , & vhost_scsi_list ) ; mutex_unlock ( & vhost_scsi_mutex ) ; return & tpg -> se_tpg ; }
","<S2SV_ModStart> * tpg ; u16 <S2SV_ModEnd> tpgt ; int <S2SV_ModStart> ; if ( kstrtou16 <S2SV_ModEnd> ( name + <S2SV_ModStart> ) || tpgt >= VHOST_SCSI_MAX_TARGET <S2SV_ModEnd> ) return ERR_PTR
",torvalds@linux/59c816c1f24df0204e01851431d3bab3eb76719c,CVE-2015-4036,https://github.com/torvalds/linux/commit/59c816c1f24df0204e01851431d3bab3eb76719c,2015-08-31T20:59Z
CWE-119,"CWE-119 static guint32 parse_wbxml_attribute_list_defined ( proto_tree * tree , tvbuff_t * tvb , guint32 offset , guint32 str_tbl , guint8 level , guint8 * codepage_attr , const wbxml_decoding * map ) { guint32 tvb_len = tvb_reported_length ( tvb ) ; <S2SV_StartBug> guint32 off = offset ; <S2SV_EndBug> guint32 len ; guint str_len ; guint32 ent ; guint32 idx ; guint8 peek ; guint8 attr_save_known = 0 ; const char * attr_save_literal = NULL ; DebugLog ( ( ""parse_wbxml_attr_defined<S2SV_blank>(level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>offset<S2SV_blank>=<S2SV_blank>%u)\\n"" , <S2SV_StartBug> level , offset ) ) ; <S2SV_EndBug> while ( off < tvb_len ) { peek = tvb_get_guint8 ( tvb , off ) ; DebugLog ( ( ""ATTR:<S2SV_blank>(top<S2SV_blank>of<S2SV_blank>while)<S2SV_blank>level<S2SV_blank>=<S2SV_blank>%3u,<S2SV_blank>peek<S2SV_blank>=<S2SV_blank>0x%02X,<S2SV_blank>"" ""off<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>tvb_len<S2SV_blank>=<S2SV_blank>%u\\n"" , level , peek , off , tvb_len ) ) ; if ( ( peek & 0x3F ) < 5 ) switch ( peek ) { case 0x00 : * codepage_attr = tvb_get_guint8 ( tvb , off + 1 ) ; proto_tree_add_text ( tree , tvb , off , 2 , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>-->%3d<S2SV_blank>"" ""|<S2SV_blank>SWITCH_PAGE<S2SV_blank>(Attr<S2SV_blank>code<S2SV_blank>page)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>|"" , * codepage_attr ) ; off += 2 ; break ; case 0x01 : off ++ ; DebugLog ( ( ""ATTR:<S2SV_blank>level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>Return:<S2SV_blank>len<S2SV_blank>=<S2SV_blank>%u\\n"" , level , off - offset ) ) ; return ( off - offset ) ; case 0x02 : ent = tvb_get_guintvar ( tvb , off + 1 , & len ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>ENTITY<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\'&#%u;\'"" , level , * codepage_attr , Indent ( level ) , ent ) ; off += 1 + len ; break ; case 0x03 : len = tvb_strsize ( tvb , off + 1 ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>STR_I<S2SV_blank>(Inline<S2SV_blank>string)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\\\'%s\\\'"" , level , * codepage_attr , Indent ( level ) , tvb_format_text ( tvb , off + 1 , len - 1 ) ) ; off += 1 + len ; break ; case 0x04 : idx = tvb_get_guintvar ( tvb , off + 1 , & len ) ; str_len = tvb_strsize ( tvb , str_tbl + idx ) ; attr_save_known = 0 ; attr_save_literal = tvb_format_text ( tvb , str_tbl + idx , str_len - 1 ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>LITERAL<S2SV_blank>(Literal<S2SV_blank>Attribute)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank>%s<%s<S2SV_blank>/>"" , level , * codepage_attr , Indent ( level ) , attr_save_literal ) ; off += 1 + len ; break ; case 0x40 : case 0x41 : case 0x42 : len = tvb_strsize ( tvb , off + 1 ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>EXT_I_%1x<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(Extension<S2SV_blank>Token)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s(%s:<S2SV_blank>\\\'%s\\\')"" , level , * codepage_attr , peek & 0x0f , Indent ( level ) , map_token ( map -> global , 0 , peek ) , tvb_format_text ( tvb , off + 1 , len - 1 ) ) ; off += 1 + len ; break ; case 0x80 : case 0x81 : case 0x82 : idx = tvb_get_guintvar ( tvb , off + 1 , & len ) ; { char * s ; if ( map -> ext_t [ peek & 0x03 ] ) s = ( map -> ext_t [ peek & 0x03 ] ) ( tvb , idx , str_tbl ) ; else s = wmem_strdup_printf ( wmem_packet_scope ( ) , ""EXT_T_%1x<S2SV_blank>(%s)"" , peek & 0x03 , map_token ( map -> global , 0 , peek ) ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank>Tag<S2SV_blank><S2SV_blank><S2SV_blank>|<S2SV_blank>T<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>EXT_T_%1x<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(Extension<S2SV_blank>Token)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>%s%s)"" , level , * codepage_attr , peek & 0x0f , Indent ( level ) , s ) ; } off += 1 + len ; break ; case 0x83 : idx = tvb_get_guintvar ( tvb , off + 1 , & len ) ; str_len = tvb_strsize ( tvb , str_tbl + idx ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>STR_T<S2SV_blank>(Tableref<S2SV_blank>string)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\\\'%s\\\'"" , level , * codepage_attr , Indent ( level ) , tvb_format_text ( tvb , str_tbl + idx , str_len - 1 ) ) ; off += 1 + len ; break ; case 0xC0 : case 0xC1 : case 0xC2 : proto_tree_add_text ( tree , tvb , off , 1 , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>EXT_%1x<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(Extension<S2SV_blank>Token)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s(%s)"" , level , * codepage_attr , peek & 0x0f , Indent ( level ) , map_token ( map -> global , 0 , peek ) ) ; off ++ ; break ; case 0xC3 : if ( tvb_get_guint8 ( tvb , 0 ) ) { char * str ; if ( attr_save_known ) { if ( map -> opaque_binary_attr ) { str = map -> opaque_binary_attr ( tvb , off + 1 , attr_save_known , * codepage_attr , & len ) ; } else { str = default_opaque_binary_attr ( tvb , off + 1 , attr_save_known , * codepage_attr , & len ) ; } } else { if ( map -> opaque_literal_tag ) { str = map -> opaque_literal_attr ( tvb , off + 1 , attr_save_literal , * codepage_attr , & len ) ; } else { str = default_opaque_literal_attr ( tvb , off + 1 , attr_save_literal , * codepage_attr , & len ) ; } } proto_tree_add_text ( tree , tvb , off , 1 + len , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>OPAQUE<S2SV_blank>(Opaque<S2SV_blank>data)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s%s"" , level , * codepage_attr , Indent ( level ) , str ) ; off += 1 + len ; } else { proto_tree_add_text ( tree , tvb , off , 1 , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>RESERVED_2<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(Invalid<S2SV_blank>Token!)<S2SV_blank>"" ""|<S2SV_blank>WBXML<S2SV_blank>1.0<S2SV_blank>parsing<S2SV_blank>stops<S2SV_blank>here."" , level , * codepage_attr ) ; off = tvb_len ; DebugLog ( ( ""ATTR:<S2SV_blank>level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>Return:<S2SV_blank>len<S2SV_blank>=<S2SV_blank>%u\\n"" , level , off - offset ) ) ; return ( off - offset ) ; } break ; default : proto_tree_add_text ( tree , tvb , off , 1 , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>%-10s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(Invalid<S2SV_blank>Token!)<S2SV_blank>"" ""|<S2SV_blank>WBXML<S2SV_blank>parsing<S2SV_blank>stops<S2SV_blank>here."" , level , * codepage_attr , val_to_str_ext ( peek , & vals_wbxml1x_global_tokens_ext , ""(unknown<S2SV_blank>0x%x)"" ) ) ; off = tvb_len ; break ; } else { if ( peek & 0x80 ) { proto_tree_add_text ( tree , tvb , off , 1 , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank>Known<S2SV_blank>attrValue<S2SV_blank>0x%02X<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s%s"" , level , * codepage_attr , peek & 0x7f , Indent ( level ) , map_token ( map -> attrValue , * codepage_attr , peek ) ) ; off ++ ; } else { attr_save_known = peek & 0x7f ; proto_tree_add_text ( tree , tvb , off , 1 , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank>Known<S2SV_blank>attrStart<S2SV_blank>0x%02X<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank>%s%s"" , level , * codepage_attr , attr_save_known , Indent ( level ) , map_token ( map -> attrStart , * codepage_attr , peek ) ) ; off ++ ; } } <S2SV_StartBug> } <S2SV_EndBug> DebugLog ( ( ""ATTR:<S2SV_blank>level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>Return:<S2SV_blank>len<S2SV_blank>=<S2SV_blank>%u<S2SV_blank>(end<S2SV_blank>of<S2SV_blank>function<S2SV_blank>body)\\n"" , level , off - offset ) ) ; return ( off - offset ) ; }
","<S2SV_ModStart> off = offset , last_off <S2SV_ModStart> offset ) ) ; last_off = off <S2SV_ModStart> ; } } if ( off < last_off ) { THROW ( ReportedBoundsError ) ; } last_off = off ;
",wireshark@wireshark/b8e0d416898bb975a02c1b55883342edc5b4c9c0,CVE-2016-5359,https://github.com/wireshark/wireshark/commit/b8e0d416898bb975a02c1b55883342edc5b4c9c0,2016-08-07T16:59Z
